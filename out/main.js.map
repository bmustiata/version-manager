{"version":3,"sources":["webpack:///webpack/bootstrap 9f1a31107a4f67e1fb21","webpack:///external \"babel-polyfill\"","webpack:///./src/main.ts","webpack:///external \"fs\"","webpack:///external \"glob\"","webpack:///external \"colors\"","webpack:///external \"path\"","webpack:///./src/SettingsReader.ts","webpack:///./src/MatcherBuilder.ts","webpack:///./src/matchers/RegExPattern.ts","webpack:///./src/matchers/StringPattern.ts","webpack:///external \"escape-string-regexp\"","webpack:///./src/matchers/MatchCounter.ts","webpack:///./src/matchers/ArrayPattern.ts","webpack:///./src/ParseVersion.ts","webpack:///external \"child_process\""],"names":[],"mappings":"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","file":"out/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9f1a31107a4f67e1fb21","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 1\n// module chunks = 0","import * as fs from \"fs\"\nimport * as glob from \"glob\"\nimport * as colors from \"colors\"\nimport * as path from \"path\"\n\nimport { readSettingsFile } from './SettingsReader'\nimport { IPattern } from \"./interfaces\"\n\nconst defaultSettingsFile = path.resolve(path.join(process.cwd(), \"versions.json\"))\nconst versionsToProcess = readSettingsFile(defaultSettingsFile);\n\nconst filesToProcess : { [name: string] : Array<IPattern> } = {}\n\nversionsToProcess.forEach((trackedVersion) => {\n  Object.keys(trackedVersion.files).forEach((fileName) => {\n    let versionPattern = trackedVersion.files[fileName]\n    let resolvedNames = glob.sync(fileName)\n\n    if (!resolvedNames || !resolvedNames.length) {\n      console.error(colors.red(`Unable to find any files for glob ${fileName}.`))\n      process.exit(2)\n    }\n\n    // first we collect all the files that we need to process\n    // into one nice map, with all the patterns that are going\n    // to run over those files.\n    resolvedNames.forEach((resolvedName) => {\n      let filePatterns = filesToProcess[resolvedName] || []\n      filePatterns.push(versionPattern)\n      filesToProcess[resolvedName] = filePatterns\n    })\n  })\n})\n\nObject.keys(filesToProcess).forEach((resolvedName) => {\n  let content = fs.readFileSync(resolvedName, \"utf-8\")\n  let newContent = content\n    \n  console.log(`Patching ${colors.cyan(resolvedName)}:`)\n\n  filesToProcess[resolvedName].forEach((versionPattern) => {\n    let trackedVersion = versionPattern.trackedVersion\n    console.log(` * ${colors.green(trackedVersion.name + '@' + trackedVersion.version)}`)\n\n    newContent = versionPattern.applyPattern(newContent)\n\n    if (versionPattern.getMatchCount() != versionPattern.getExpectedCount()) {\n      console.error(\n        colors.red(\n          `Got ${versionPattern.getMatchCount()} matches ` +\n          `instead of ${versionPattern.getExpectedCount()}.`))\n      process.exit(3)\n    }\n  })\n\n  if (content == newContent) {\n    console.log(colors.cyan(`Content for ${resolvedName} is not changed. Won't patch it.`))\n    return;\n  }\n\n  fs.writeFileSync(resolvedName, newContent, \"utf-8\")\n  console.log(colors.yellow(`Updated ${resolvedName}`))\n})\n\nprocess.exit(0);\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"glob\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"glob\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"colors\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"colors\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 6\n// module chunks = 0","import * as colors from \"colors\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\n\nimport { ITrackedVersionSet, ITrackedVersion } from \"./interfaces\"\nimport { matcherBuilder } from \"./MatcherBuilder\"\nimport { parseVersion } from \"./ParseVersion\"\n\n\n/**\n * readSettingsFile - Read the settings file.\n * @return {ITrackedVersionSet}\n */\nexport function readSettingsFile(settingsFile: string) : ITrackedVersionSet {\n  if (!settingsFileExists(settingsFile)) {\n    reportMissingSettingsFile(settingsFile);\n    process.exit(1);\n  }\n\n  const settings = JSON.parse(fs.readFileSync(settingsFile, \"utf-8\"));\n\n  return Object.keys(settings)\n    .map((key) => {\n      let trackedEntry = settings[key]\n\n      trackedEntry.name = key\n      trackedEntry.version = parseVersion(trackedEntry.version)\n\n      Object.keys(trackedEntry.files).forEach((file) => {\n        trackedEntry.files[file] = matcherBuilder(trackedEntry, trackedEntry.files[file])\n      })\n\n      return <ITrackedVersion> trackedEntry\n    });\n}\n\nfunction settingsFileExists(settingsFile: string) {\n  return fs.existsSync(settingsFile);\n}\n\nfunction reportMissingSettingsFile(settingsFile: string) {\n  console.log(colors.red(settingsFile + \" configuration file is missing.\"));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SettingsReader.ts","import { ITrackedVersion, IPattern } from \"./interfaces\"\nimport { RegExPattern } from \"./matchers/RegExPattern\"\nimport { StringPattern } from \"./matchers/StringPattern\"\nimport { MatchCounter } from \"./matchers/MatchCounter\"\nimport { ArrayPattern } from \"./matchers/ArrayPattern\"\n\nexport function matcherBuilder(trackedVersion: ITrackedVersion, fileItem: any) : IPattern {\n  if (fileItem instanceof Array) {\n    return new ArrayPattern(\n      trackedVersion, \n      fileItem.map((it) => matcherBuilder(trackedVersion, it)))\n  }\n\n  if (typeof fileItem['count'] != \"undefined\") {\n    return new MatchCounter(\n      trackedVersion,\n      matcherBuilder(\n          trackedVersion,\n          fileItem.match || fileItem.expression),\n      fileItem.count\n    );\n  }\n\n  if (fileItem.indexOf(\"##VERSION##\") != -1) {\n    return new StringPattern(trackedVersion, fileItem)\n  }\n\n  return new RegExPattern(trackedVersion, fileItem)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MatcherBuilder.ts","import { ITrackedVersion, IPattern } from \"../interfaces\"\n\nexport class RegExPattern implements IPattern {\n  private RE: RegExp\n  private matchCount : number = 0\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    this.RE = new RegExp(expression, \"gm\")\n  }\n\n  applyPattern(input: string) : string {\n    let match : RegExpExecArray\n    let foundMatches: Array<RegExpExecArray> = []\n\n    while (match = this.RE.exec(input)) {\n      this.matchCount++\n      this.RE.lastIndex = match.index + match[0].length\n\n      foundMatches.push(match)\n    }\n\n    // this tracks the original input, since the matches are done\n    // aginst the unmodified string.\n    let originalIndex = 0\n    let originalInput = input\n\n    let result = \"\"\n\n    foundMatches.forEach((match) => {\n      result += originalInput.substring(originalIndex, match.index) +\n                match[1] +\n                this.trackedVersion.version +\n               (match[3] ? match[3] : \"\");\n      originalIndex = match.index + match[0].length\n    })\n\n    result += originalInput.substring(originalIndex, originalInput.length)\n\n    return result\n  }\n\n  getMatchCount() : number {\n    return this.matchCount\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/RegExPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\nimport { RegExPattern } from \"./RegExPattern\"\nimport escapeStringRegexp = require(\"escape-string-regexp\")\n\nexport class StringPattern implements IPattern {\n  private _regexPattern : RegExPattern\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    let escapedExpression = escapeStringRegexp(expression);\n    let reTokens = escapedExpression.split(\"##VERSION##\")\n\n    this._regexPattern = new RegExPattern(trackedVersion, `(${reTokens[0]})(.*?)(${reTokens[1]})`)\n  }\n\n  applyPattern(input: string) : string {\n    return this._regexPattern.applyPattern(input)\n  }\n\n  getMatchCount() : number {\n    return this._regexPattern.getMatchCount()\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/StringPattern.ts","module.exports = require(\"escape-string-regexp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"escape-string-regexp\"\n// module id = 11\n// module chunks = 0","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class MatchCounter implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePattern : IPattern,\n                private expectedCount : number) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePattern.applyPattern(input)     \n    }\n\n    getMatchCount() : number {\n        if (this.expectedCount < 0) {\n            return this.expectedCount\n        }\n\n        return this.delegatePattern.getMatchCount()\n    }\n\n    getExpectedCount() : number {\n        return this.expectedCount\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/MatchCounter.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class ArrayPattern implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePatterns : Array<IPattern>) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePatterns\n            .reduce((input, pattern) => pattern.applyPattern(input), input)\n    }\n\n    getMatchCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getMatchCount())\n            .reduce((x, y) => x + y, 0)\n    }\n    \n    getExpectedCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getExpectedCount())\n            .reduce((x, y) => x + y, 0)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/ArrayPattern.ts","import * as child_process from \"child_process\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\nimport { readSettingsFile } from \"./SettingsReader\"\nimport { ITrackedVersionSet } from \"./interfaces\"\n\n// cache the settings files.\nconst settingFiles : {[name: string]: ITrackedVersionSet} = {}\n\nfunction parseParentPath(version: string, cwd: string) : string {\n    const items = /^parent:(.+)@(.+?)$/.exec(version)\n\n    if (!items) {\n        throw new Error(`The version must be in the 'parent:path@propertyname' ` +\n                        `format, got instead: '${version}'.`)\n    }\n\n    const parentVersionsFilePath = items[1]\n    const propertyName = items[2]\n\n    let fullPath = path.resolve(path.join(cwd, items[1]))\n\n    if (!fs.existsSync(fullPath)) {\n        throw new Error(`Unable to find referenced file: ${fullPath}`)\n    }\n\n    if (fs.statSync(fullPath).isDirectory()) {\n        fullPath = path.join(fullPath, \"versions.json\")\n    }\n\n    if (!settingFiles[fullPath]) {\n        settingFiles[fullPath] = readSettingsFile(fullPath)\n    }\n\n    const propertyValue = settingFiles[fullPath]\n                        .find(it => it.name == propertyName)\n\n    if (!propertyValue) {\n        const availableProperties = settingFiles[fullPath]\n                .map(it => `${it.name}@${it.version}`)\n                .join(\", \");\n\n        throw new Error(`Property '${propertyName}' is not defined in ${fullPath}`\n            + ` settings file. Available properties are: ${availableProperties}.`)\n    }\n\n    return propertyValue.version\n}\n\nfunction parseVersionWithPath(version: string, cwd: string) : string {\n    // from here, the path becomes important, since the process execution\n    // and the parent: referening depends on where the currently parsed\n    // versions.json file is being parsed from.\n    const oldPath = process.cwd()\n\n    try {\n        process.chdir(cwd)\n\n        // check if this is not an external json file, in the\n        // format: parent:../path/to/versions.json:property_name\n        // or    : parent:../path/to:property_name\n        if (version.startsWith('parent:')) {\n            return parseParentPath(version, cwd);\n        }\n\n        // if we don't need to execute anything, just go\n        // and return the current version.\n        if (version.indexOf('`') == -1 && version.indexOf(\"$\") == -1) {\n            return version\n        }\n\n        return child_process.execSync(`echo -n \"${version}\"`, {encoding: \"utf8\"})\n    } finally {\n        process.chdir(oldPath)\n    }\n}\n\n/**\n * Parse the given version string.\n */\nexport function parseVersion(version: string) : string {\n    return parseVersionWithPath(version, process.cwd());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ParseVersion.ts","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}