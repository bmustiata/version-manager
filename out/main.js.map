{"version":3,"sources":["webpack:///webpack/bootstrap b3101ce89fb22804e571","webpack:///external \"babel-polyfill\"","webpack:///./src/main.ts","webpack:///external \"fs\"","webpack:///external \"glob\"","webpack:///external \"colors\"","webpack:///./src/SettingsReader.ts","webpack:///external \"path\"","webpack:///./src/MatcherBuilder.ts","webpack:///./src/matchers/RegExPattern.ts","webpack:///./src/matchers/StringPattern.ts","webpack:///./src/ParseVersion.ts","webpack:///external \"child_process\""],"names":[],"mappings":"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","file":"out/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b3101ce89fb22804e571","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 1\n// module chunks = 0","import * as fs from \"fs\"\nimport * as glob from \"glob\"\nimport * as colors from \"colors\"\n\nimport { readSettingsFile } from './SettingsReader'\n\nconst versionsToProcess = readSettingsFile();\n\nversionsToProcess.forEach((trackedVersion) => {\n  Object.keys(trackedVersion.files).forEach((fileName) => {\n    let versionPattern = trackedVersion.files[fileName]\n    let resolvedNames = glob.sync(fileName)\n\n    if (!resolvedNames || !resolvedNames.length) {\n      console.error(colors.red(`Unable to find any files for glob ${fileName}.`))\n      process.exit(2)\n    }\n\n    resolvedNames.forEach((resolvedName) => {\n      console.log(`${colors.cyan(fileName)}: Patching ${colors.cyan(resolvedName)} ` + \n            `for ${colors.green(trackedVersion.name + '@' + trackedVersion.version)}`)\n\n      let content = fs.readFileSync(fileName, \"utf-8\")\n      let newContent = versionPattern.applyPattern(content)\n    \n      // FIXME: there should be a way to specify how many should be in.\n      if (versionPattern.getMatchCount() != 1) {\n        console.error(colors.red(\"Matches != 1.\"))\n        process.exit(3)\n      }\n\n      fs.writeFileSync(resolvedName, newContent, \"utf-8\")\n    })\n  })\n})\n\nprocess.exit(0);\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"glob\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"glob\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"colors\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"colors\"\n// module id = 5\n// module chunks = 0","import * as colors from \"colors\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\n\nimport { ITrackedVersionSet, ITrackedVersion } from \"./interfaces\"\nimport { matcherBuilder } from \"./MatcherBuilder\"\nimport { parseVersion } from \"./ParseVersion\"\n\nconst settingsFile = path.join(process.cwd(), \"versions.json\");\n\n\n/**\n * readSettingsFile - Read the settings file.\n * @return {Object}\n */\nexport function readSettingsFile() : ITrackedVersionSet {\n  if (!settingsFileExists()) {\n    reportMissingSettingsFile();\n    process.exit(1);\n  }\n\n  const settings = JSON.parse(fs.readFileSync(settingsFile, \"utf-8\"));\n\n  return Object.keys(settings)\n    .map((key) => {\n      let trackedEntry = settings[key]\n\n      trackedEntry.name = key\n      trackedEntry.version = parseVersion(trackedEntry.version)\n\n      Object.keys(trackedEntry.files).forEach((file) => {\n        trackedEntry.files[file] = matcherBuilder(trackedEntry, trackedEntry.files[file])\n      })\n\n      return <ITrackedVersion> trackedEntry\n    });\n}\n\nfunction settingsFileExists() {\n  return fs.existsSync(settingsFile);\n}\n\nfunction reportMissingSettingsFile() {\n  console.log(colors.red(settingsFile + \" configuration file is missing.\"));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SettingsReader.ts","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 7\n// module chunks = 0","import { ITrackedVersion, IPattern } from \"./interfaces\"\nimport { RegExPattern } from \"./matchers/RegExPattern\"\nimport { StringPattern } from \"./matchers/StringPattern\"\n\nexport function matcherBuilder(trackedVersion: ITrackedVersion, fileItem: string) : IPattern {\n  if (fileItem.includes(\"##VERSION##\")) {\n    return new StringPattern(trackedVersion, fileItem)\n  }\n\n  return new RegExPattern(trackedVersion, fileItem)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MatcherBuilder.ts","import { ITrackedVersion, IPattern } from \"../interfaces\"\n\nexport class RegExPattern implements IPattern {\n  private RE: RegExp\n  private matchCount : number = 0\n\n  constructor(private trackedVersion: ITrackedVersion,\n              private expression: string) {\n    this.RE = new RegExp(expression, \"gm\")\n  }\n\n  applyPattern(input: string) : string {\n    let match : RegExpExecArray\n    let foundMatches: Array<RegExpExecArray> = []\n\n    while (match = this.RE.exec(input)) {\n      this.matchCount++\n      this.RE.lastIndex = match.index + match[0].length\n\n      foundMatches.push(match)\n    }\n\n    // this tracks the original input, since the matches are done\n    // aginst the unmodified string.\n    let originalIndex = 0\n    let originalInput = input\n\n    let result = \"\"\n\n    foundMatches.forEach((match) => {\n      result += originalInput.substring(originalIndex, match.index) +\n                match[1] +\n                this.trackedVersion.version +\n                match[3];\n      originalIndex = match.index + match[0].length\n    })\n\n    result += originalInput.substring(originalIndex, originalInput.length)\n\n    return result\n  }\n\n  getMatchCount() : number {\n    return this.matchCount\n  }   \n}\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/RegExPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\nimport { RegExPattern } from \"./RegExPattern\"\n\nexport class StringPattern implements IPattern {\n  private _regexPattern : RegExPattern\n\n  constructor(private trackedVersion: ITrackedVersion,\n              private expression: string) {\n    let reTokens = expression.split(\"##VERSION##\")\n\n    this._regexPattern = new RegExPattern(trackedVersion, `(${reTokens[0]})(.*?)(${reTokens[1]})`)\n  }\n  \n  applyPattern(input: string) : string {\n    return this._regexPattern.applyPattern(input)\n  }\n\n  getMatchCount() : number {\n    return this._regexPattern.getMatchCount()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/StringPattern.ts","import * as child_process from \"child_process\"\n\n/**\n * Parse the given version string.\n */\nexport function parseVersion(version: string) : string {\n    // if we don't need to execute anything, just go\n    // and return the current version.\n    if (! version.includes('`') && ! version.includes(\"$\")) {\n        return version\n    }\n\n    return child_process.execSync(`echo \"${version}\"`, {encoding: \"utf8\"})\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ParseVersion.ts","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}