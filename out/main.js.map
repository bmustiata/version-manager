{"version":3,"sources":["webpack:///webpack/bootstrap a806e526399432a4cd96","webpack:///external \"babel-polyfill\"","webpack:///./src/main.ts","webpack:///external \"fs\"","webpack:///external \"glob\"","webpack:///external \"colors\"","webpack:///external \"path\"","webpack:///./src/SettingsReader.ts","webpack:///external \"js-yaml\"","webpack:///./src/MatcherBuilder.ts","webpack:///./src/matchers/RegExPattern.ts","webpack:///./src/matchers/StringPattern.ts","webpack:///external \"escape-string-regexp\"","webpack:///./src/matchers/MavenPattern.ts","webpack:///./src/matchers/MatchCounter.ts","webpack:///./src/matchers/ArrayPattern.ts","webpack:///./src/ParseVersion.ts","webpack:///external \"child_process\"","webpack:///./~/nomnom/nomnom.js","webpack:///./~/underscore/underscore.js","webpack:///external \"chalk\""],"names":[],"mappings":"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CtB,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA,wDAAuD,iBAAiB,EAAE;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvkBA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,2CAA0C,YAAY;AACtD;AACA;AACA,MAAK;AACL;AACA,4CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,4CAA2C,iCAAiC,EAAE;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,YAAY;AACrD;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAU,YAAY;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,8BAA8B,EAAE;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,+BAA+B,EAAE;AAClE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO,eAAe;AACtB;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAAyC,YAAY;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,sDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,6BAA6B;;AAE/D;AACA;AACA;AACA,kBAAiB;AACjB,iBAAgB;AAChB,iBAAgB;AAChB,mBAAkB;AAClB,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C,8BAA8B,EAAE;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,MAAK;AACL,kBAAiB;;AAEjB;AACA,mDAAkD,EAAE,iBAAiB;;AAErE;AACA,yBAAwB,8BAA8B;AACtD,4BAA2B;;AAE3B;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAsE,iBAAiB;;AAEvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;;;;;;AC9zCD,mC","file":"out/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a806e526399432a4cd96","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 1\n// module chunks = 0","import * as fs from \"fs\"\nimport * as glob from \"glob\"\nimport * as colors from \"colors\"\nimport * as path from \"path\"\nimport * as nomnom from \"nomnom\"\n\nimport { readSettingsFile } from './SettingsReader'\nimport { IPattern } from \"./interfaces\"\n\nconst argv = nomnom.option('version', {\n  abbr: 'v',\n  help: 'Display the version of a single tracked version.'\n}).parse();\n\nconst defaultSettingsFile = path.resolve(path.join(process.cwd(), \"versions.json\"))\nconst versionsToProcess = readSettingsFile(defaultSettingsFile);\n\nif (argv.version) {\n  let trackedVersion = versionsToProcess.find(it => it.name == argv.version)\n  if (!trackedVersion) {\n    console.error(`Tracked version '${argv.version}' does not exist. Available are: ${versionsToProcess.map(it => `'${it.name}'`).join(\", \")}.`)\n    process.exit(1)\n  }\n\n  console.log(trackedVersion.version);\n  process.exit(0);\n}\n\nconst filesToProcess : { [name: string] : Array<IPattern> } = {}\n\nlet changedFiles: boolean = false\n\nversionsToProcess.forEach((trackedVersion) => {\n  Object.keys(trackedVersion.files).forEach((fileName) => {\n    let versionPattern = trackedVersion.files[fileName]\n    let resolvedNames = glob.sync(fileName)\n\n    if (!resolvedNames || !resolvedNames.length) {\n      console.error(colors.red(`Unable to find any files for glob ${fileName}.`))\n      process.exit(2)\n    }\n\n    // first we collect all the files that we need to process\n    // into one nice map, with all the patterns that are going\n    // to run over those files.\n    resolvedNames.forEach((resolvedName) => {\n      let filePatterns = filesToProcess[resolvedName] || []\n      filePatterns.push(versionPattern)\n      filesToProcess[resolvedName] = filePatterns\n    })\n  })\n})\n\nObject.keys(filesToProcess).forEach((resolvedName) => {\n  let content = fs.readFileSync(resolvedName, \"utf-8\")\n  let newContent = content\n    \n  console.log(`Patching ${colors.cyan(resolvedName)}:`)\n\n  filesToProcess[resolvedName].forEach((versionPattern) => {\n    let trackedVersion = versionPattern.trackedVersion\n    console.log(` * ${colors.green(trackedVersion.name + '@' + trackedVersion.version)}`)\n\n    newContent = versionPattern.applyPattern(newContent)\n\n    if (versionPattern.getMatchCount() != versionPattern.getExpectedCount()) {\n      console.error(\n        colors.red(\n          `Got ${versionPattern.getMatchCount()} matches ` +\n          `instead of ${versionPattern.getExpectedCount()}.`))\n      process.exit(3)\n    }\n  })\n\n  if (content == newContent) {\n    console.log(colors.cyan(`Content for ${resolvedName} is not changed. Won't patch it.`))\n    return;\n  }\n\n  changedFiles = true;\n\n  fs.writeFileSync(resolvedName, newContent, \"utf-8\")\n  console.log(colors.yellow(`Updated ${resolvedName}`))\n})\n\nprocess.exit(changedFiles? 200 : 0);\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"glob\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"glob\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"colors\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"colors\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 6\n// module chunks = 0","import * as colors from \"colors\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\nimport * as yaml from \"js-yaml\"\n\nimport { ITrackedVersionSet, ITrackedVersion } from \"./interfaces\"\nimport { matcherBuilder } from \"./MatcherBuilder\"\nimport { parseVersion } from \"./ParseVersion\"\n\n\n/**\n * readSettingsFile - Read the settings file.\n * @return {ITrackedVersionSet}\n */\nexport function readSettingsFile(settingsFile: string) : ITrackedVersionSet {\n  if (!settingsFileExists(settingsFile)) {\n    settingsFile = path.join(path.dirname(settingsFile), \"versions.yml\")\n\n    if (!settingsFileExists(settingsFile)) {\n      reportMissingSettingsFile(settingsFile);\n      process.exit(1);\n    }\n  }\n\n  const settings = yaml.load(fs.readFileSync(settingsFile, \"utf-8\"));\n\n  return Object.keys(settings)\n    .map((key) => {\n      let trackedEntry = settings[key]\n\n      trackedEntry.name = key\n      trackedEntry.version = parseVersion(trackedEntry.version)\n      \n      // made the files optional, so we can have \"bom\" version files\n      if (!trackedEntry.files) {\n        trackedEntry.files = {};\n      }\n\n      Object.keys(trackedEntry.files).forEach((file) => {\n        trackedEntry.files[file] = matcherBuilder(trackedEntry, trackedEntry.files[file])\n      })\n\n      return <ITrackedVersion> trackedEntry\n    });\n}\n\nfunction settingsFileExists(settingsFile: string) {\n  return fs.existsSync(settingsFile);\n}\n\nfunction reportMissingSettingsFile(settingsFile: string) {\n  console.log(colors.red(settingsFile + \" configuration file is missing.\"));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SettingsReader.ts","module.exports = require(\"js-yaml\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-yaml\"\n// module id = 8\n// module chunks = 0","import { ITrackedVersion, IPattern } from \"./interfaces\"\nimport { RegExPattern } from \"./matchers/RegExPattern\"\nimport { StringPattern } from \"./matchers/StringPattern\"\nimport { MavenPattern } from \"./matchers/MavenPattern\"\nimport { MatchCounter } from \"./matchers/MatchCounter\"\nimport { ArrayPattern } from \"./matchers/ArrayPattern\"\n\nexport function matcherBuilder(trackedVersion: ITrackedVersion, fileItem: any) : IPattern {\n  if (fileItem instanceof Array) {\n    return new ArrayPattern(\n      trackedVersion, \n      fileItem.map((it) => matcherBuilder(trackedVersion, it)))\n  }\n\n  if (typeof fileItem['count'] != \"undefined\") {\n    return new MatchCounter(\n      trackedVersion,\n      matcherBuilder(\n          trackedVersion,\n          fileItem.match || fileItem.expression),\n      fileItem.count\n    );\n  }\n\n  if (MavenPattern.RE.test(fileItem)) {\n    return new MavenPattern(trackedVersion, fileItem)\n  }\n\n  if (StringPattern.RE.test(fileItem)) {\n    return new StringPattern(trackedVersion, fileItem)\n  }\n\n  return new RegExPattern(trackedVersion, fileItem)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MatcherBuilder.ts","import { ITrackedVersion, IPattern } from \"../interfaces\"\n\nexport class RegExPattern implements IPattern {\n  private RE: RegExp\n  private matchCount : number = 0\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    this.RE = new RegExp(expression, \"gm\")\n  }\n\n  applyPattern(input: string) : string {\n    let match : RegExpExecArray\n    let foundMatches: Array<RegExpExecArray> = []\n\n    while (match = this.RE.exec(input)) {\n      this.matchCount++\n      this.RE.lastIndex = match.index + match[0].length\n\n      foundMatches.push(match)\n    }\n\n    // this tracks the original input, since the matches are done\n    // aginst the unmodified string.\n    let originalIndex = 0\n    let originalInput = input\n\n    let result = \"\"\n\n    foundMatches.forEach((match) => {\n      result += originalInput.substring(originalIndex, match.index) +\n                match[1] +\n                this.trackedVersion.version +\n               (match[3] ? match[3] : \"\");\n      originalIndex = match.index + match[0].length\n    })\n\n    result += originalInput.substring(originalIndex, originalInput.length)\n\n    return result\n  }\n\n  getMatchCount() : number {\n    return this.matchCount\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/RegExPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\nimport { RegExPattern } from \"./RegExPattern\"\nimport escapeStringRegexp = require(\"escape-string-regexp\")\n\nexport class StringPattern implements IPattern {\n  private _regexPattern : RegExPattern\n\n  public static RE = /^(.*?)(\\^\\^|##|\\*\\*)VERSION(##|\\*\\*|\\$\\$)(.*?)$/;\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    const m = StringPattern.RE.exec(expression)\n\n    if (m[2] == '##' || m[3] == '##') {\n      console.warn(`Version matched using expression '${expression}' ` +\n              `still uses the old '##' notation for delimiting the `  +\n              `version. This is not supported anymore since # denotes ` +\n              `a comment in YAML. Use '**' instead.`)\n    }\n\n    const regexpValue = `${m[2] == '^^' ? '^()' : `(${escapeStringRegexp(m[1])})`}` +\n                        `(.*?)` + \n                        `${m[3] == '$$' ? '$' : `(${escapeStringRegexp(m[4])})`}`;\n\n    this._regexPattern = new RegExPattern(trackedVersion, regexpValue)\n  }\n\n  applyPattern(input: string) : string {\n    return this._regexPattern.applyPattern(input)\n  }\n\n  getMatchCount() : number {\n    return this._regexPattern.getMatchCount()\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/StringPattern.ts","module.exports = require(\"escape-string-regexp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"escape-string-regexp\"\n// module id = 12\n// module chunks = 0","import { IPattern, ITrackedVersion } from \"../interfaces\"\nimport { RegExPattern } from \"./RegExPattern\"\nimport escapeStringRegexp = require(\"escape-string-regexp\")\n\nexport class MavenPattern implements IPattern {\n  private _regexPattern : RegExPattern\n\n  public static RE = /^maven\\:(.*?)\\:(.*?)$/;\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    const m = MavenPattern.RE.exec(expression)\n\n    const regexpValue = `(<groupId>${escapeStringRegexp(m[1])}</groupId>\\\\s*` +\n                        `<artifactId>${escapeStringRegexp(m[2])}</artifactId>\\\\s*` + \n                        `<version>)(.*?)(</version>)`;\n\n    this._regexPattern = new RegExPattern(trackedVersion, regexpValue)\n  }\n\n  applyPattern(input: string) : string {\n    return this._regexPattern.applyPattern(input)\n  }\n\n  getMatchCount() : number {\n    return this._regexPattern.getMatchCount()\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/MavenPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class MatchCounter implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePattern : IPattern,\n                private expectedCount : number) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePattern.applyPattern(input)     \n    }\n\n    getMatchCount() : number {\n        if (this.expectedCount < 0) {\n            return this.expectedCount\n        }\n\n        return this.delegatePattern.getMatchCount()\n    }\n\n    getExpectedCount() : number {\n        return this.expectedCount\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/MatchCounter.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class ArrayPattern implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePatterns : Array<IPattern>) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePatterns\n            .reduce((input, pattern) => pattern.applyPattern(input), input)\n    }\n\n    getMatchCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getMatchCount())\n            .reduce((x, y) => x + y, 0)\n    }\n    \n    getExpectedCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getExpectedCount())\n            .reduce((x, y) => x + y, 0)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/ArrayPattern.ts","import * as child_process from \"child_process\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\nimport { readSettingsFile } from \"./SettingsReader\"\nimport { ITrackedVersionSet } from \"./interfaces\"\n\n// cache the settings files.\nconst settingFiles : {[name: string]: ITrackedVersionSet} = {}\n\nfunction parseParentPath(version: string, cwd: string) : string {\n    const items = /^parent:(.+)@(.+?)$/.exec(version)\n\n    if (!items) {\n        throw new Error(`The version must be in the 'parent:path@propertyname' ` +\n                        `format, got instead: '${version}'.`)\n    }\n\n    const parentVersionsFilePath = items[1]\n    const propertyName = items[2]\n\n    let fullPath = path.resolve(path.join(cwd, items[1]))\n\n    if (!fs.existsSync(fullPath)) {\n        throw new Error(`Unable to find referenced file: ${fullPath}`)\n    }\n\n    if (fs.statSync(fullPath).isDirectory()) {\n        fullPath = path.join(fullPath, \"versions.json\")\n    }\n\n    if (!settingFiles[fullPath]) {\n        settingFiles[fullPath] = readSettingsFile(fullPath)\n    }\n\n    const propertyValue = settingFiles[fullPath]\n                        .find(it => it.name == propertyName)\n\n    if (!propertyValue) {\n        const availableProperties = settingFiles[fullPath]\n                .map(it => `${it.name}@${it.version}`)\n                .join(\", \");\n\n        throw new Error(`Property '${propertyName}' is not defined in ${fullPath}`\n            + ` settings file. Available properties are: ${availableProperties}.`)\n    }\n\n    return propertyValue.version\n}\n\nfunction parseVersionWithPath(version: string, cwd: string) : string {\n    // from here, the path becomes important, since the process execution\n    // and the parent: referening depends on where the currently parsed\n    // versions.json file is being parsed from.\n    const oldPath = process.cwd()\n\n    if (typeof version !== \"string\") {\n        throw new Error(`Got version a ${version} of type ${typeof version}, in ${cwd}.`)\n    }\n\n    try {\n        process.chdir(cwd)\n\n        // check if this is not an external json file, in the\n        // format: parent:../path/to/versions.json:property_name\n        // or    : parent:../path/to:property_name\n        if (version.startsWith('parent:')) {\n            return parseParentPath(version, cwd);\n        }\n\n        // if we don't need to execute anything, just go\n        // and return the current version.\n        if (version.indexOf('`') == -1 && version.indexOf(\"$\") == -1) {\n            return version\n        }\n\n        return child_process.execSync(`echo -n \"${version}\"`, {encoding: \"utf8\"})\n    } finally {\n        process.chdir(oldPath)\n    }\n}\n\n/**\n * Parse the given version string.\n */\nexport function parseVersion(version: string) : string {\n    return parseVersionWithPath(version, process.cwd());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ParseVersion.ts","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 17\n// module chunks = 0","var _ = require(\"underscore\"), chalk = require('chalk');\n\n\nfunction ArgParser() {\n   this.commands = {};  // expected commands\n   this.specs = {};     // option specifications\n}\n\nArgParser.prototype = {\n  /* Add a command to the expected commands */\n  command : function(name) {\n    var command;\n    if (name) {\n      command = this.commands[name] = {\n        name: name,\n        specs: {}\n      };\n    }\n    else {\n      command = this.fallback = {\n        specs: {}\n      };\n    }\n\n    // facilitates command('name').options().cb().help()\n    var chain = {\n      options : function(specs) {\n        command.specs = specs;\n        return chain;\n      },\n      opts : function(specs) {\n        // old API\n        return this.options(specs);\n      },\n      option : function(name, spec) {\n        command.specs[name] = spec;\n        return chain;\n      },\n      callback : function(cb) {\n        command.cb = cb;\n        return chain;\n      },\n      help : function(help) {\n        command.help = help;\n        return chain;\n      },\n      usage : function(usage) {\n        command._usage = usage;\n        return chain;\n      }\n    };\n    return chain;\n  },\n\n  nocommand : function() {\n    return this.command();\n  },\n\n  options : function(specs) {\n    this.specs = specs;\n    return this;\n  },\n\n  opts : function(specs) {\n    // old API\n    return this.options(specs);\n  },\n\n  globalOpts : function(specs) {\n    // old API\n    return this.options(specs);\n  },\n\n  option : function(name, spec) {\n    this.specs[name] = spec;\n    return this;\n  },\n\n  usage : function(usage) {\n    this._usage = usage;\n    return this;\n  },\n\n  printer : function(print) {\n    this.print = print;\n    return this;\n  },\n\n  script : function(script) {\n    this._script = script;\n    return this;\n  },\n\n  scriptName : function(script) {\n    // old API\n    return this.script(script);\n  },\n\n  help : function(help) {\n    this._help = help;\n    return this;\n  },\n\n  colors: function() {\n    // deprecated - colors are on by default now\n    return this;\n  },\n\n  nocolors : function() {\n    this._nocolors = true;\n    return this;\n  },\n\n  parseArgs : function(argv) {\n    // old API\n    return this.parse(argv);\n  },\n\n  nom : function(argv) {\n    return this.parse(argv);\n  },\n\n  parse : function(argv) {\n    this.print = this.print || function(str, code) {\n      console.log(str);\n      process.exit(code || 0);\n    };\n    this._help = this._help || \"\";\n    this._script = this._script || process.argv[0] + \" \"\n          + require('path').basename(process.argv[1]);\n    this.specs = this.specs || {};\n\n    var argv = argv || process.argv.slice(2);\n\n    var arg = Arg(argv[0]).isValue && argv[0],\n        command = arg && this.commands[arg],\n        commandExpected = !_(this.commands).isEmpty();\n\n    if (commandExpected) {\n       if (command) {\n          _(this.specs).extend(command.specs);\n          this._script += \" \" + command.name;\n          if (command.help) {\n            this._help = command.help;\n          }\n          this.command = command;\n       }\n       else if (arg) {\n          return this.print(this._script + \": no such command '\" + arg + \"'\", 1);\n       }\n       else {\n          // no command but command expected e.g. 'git -v'\n          var helpStringBuilder = {\n            list : function() {\n               return 'one of: ' + _(this.commands).keys().join(\", \");\n            },\n            twoColumn : function() {\n              // find the longest command name to ensure horizontal alignment\n              var maxLength = _(this.commands).max(function (cmd) {\n                return cmd.name.length;\n              }).name.length;\n\n              // create the two column text strings\n              var cmdHelp = _.map(this.commands, function(cmd, name) {\n                var diff = maxLength - name.length;\n                var pad = new Array(diff + 4).join(\" \");\n                return \"  \" + [ name, pad, cmd.help ].join(\" \");\n              });\n              return \"\\n\" + cmdHelp.join(\"\\n\");\n            }\n          };\n\n          // if there are a small number of commands and all have help strings,\n          // display them in a two column table; otherwise use the brief version.\n          // The arbitrary choice of \"20\" comes from the number commands git\n          // displays as \"common commands\"\n          var helpType = 'list';\n          if (_(this.commands).size() <= 20) {\n            if (_(this.commands).every(function (cmd) { return cmd.help; })) {\n                helpType = 'twoColumn';\n            }\n          }\n\n          this.specs.command = {\n            position: 0,\n            help: helpStringBuilder[helpType].call(this)\n          }\n\n          if (this.fallback) {\n            _(this.specs).extend(this.fallback.specs);\n            this._help = this.fallback.help;\n          } else {\n            this.specs.command.required = true;\n          }\n       }\n    }\n\n    if (this.specs.length === undefined) {\n      // specs is a hash not an array\n      this.specs = _(this.specs).map(function(opt, name) {\n        opt.name = name;\n        return opt;\n      });\n    }\n    this.specs = this.specs.map(function(opt) {\n      return Opt(opt);\n    });\n\n    if (argv.indexOf(\"--help\") >= 0 || argv.indexOf(\"-h\") >= 0) {\n      return this.print(this.getUsage());\n    }\n\n    var options = {};\n    var args = argv.map(function(arg) {\n      return Arg(arg);\n    })\n    .concat(Arg());\n\n    var positionals = [];\n\n    /* parse the args */\n    var that = this;\n    args.reduce(function(arg, val) {\n      /* positional */\n      if (arg.isValue) {\n        positionals.push(arg.value);\n      }\n      else if (arg.chars) {\n        var last = arg.chars.pop();\n\n        /* -cfv */\n        (arg.chars).forEach(function(ch) {\n          that.setOption(options, ch, true);\n        });\n\n        /* -v key */\n        if (!that.opt(last).flag) {\n           if (val.isValue)  {\n              that.setOption(options, last, val.value);\n              return Arg(); // skip next turn - swallow arg\n           }\n           else {\n              that.print(\"'-\" + (that.opt(last).name || last) + \"'\"\n                + \" expects a value\\n\\n\" + that.getUsage(), 1);\n           }\n        }\n        else {\n          /* -v */\n          that.setOption(options, last, true);\n        }\n\n      }\n      else if (arg.full) {\n        var value = arg.value;\n\n        /* --key */\n        if (value === undefined) {\n          /* --key value */\n          if (!that.opt(arg.full).flag) {\n            if (val.isValue) {\n              that.setOption(options, arg.full, val.value);\n              return Arg();\n            }\n            else {\n              that.print(\"'--\" + (that.opt(arg.full).name || arg.full) + \"'\"\n                + \" expects a value\\n\\n\" + that.getUsage(), 1);\n            }\n          }\n          else {\n            /* --flag */\n            value = true;\n          }\n        }\n        that.setOption(options, arg.full, value);\n      }\n      return val;\n    });\n\n    positionals.forEach(function(pos, index) {\n      this.setOption(options, index, pos);\n    }, this);\n\n    options._ = positionals;\n\n    this.specs.forEach(function(opt) {\n      if (opt.default !== undefined && options[opt.name] === undefined) {\n        options[opt.name] = opt.default;\n      }\n    }, this);\n\n    // exit if required arg isn't present\n    this.specs.forEach(function(opt) {\n      if (opt.required && options[opt.name] === undefined) {\n         var msg = opt.name + \" argument is required\";\n         msg = this._nocolors ? msg : chalk.red(msg);\n\n         this.print(\"\\n\" + msg + \"\\n\" + this.getUsage(), 1);\n      }\n    }, this);\n\n    if (command && command.cb) {\n      command.cb(options);\n    }\n    else if (this.fallback && this.fallback.cb) {\n      this.fallback.cb(options);\n    }\n\n    return options;\n  },\n\n  getUsage : function() {\n    if (this.command && this.command._usage) {\n      return this.command._usage;\n    }\n    else if (this.fallback && this.fallback._usage) {\n      return this.fallback._usage;\n    }\n    if (this._usage) {\n      return this._usage;\n    }\n\n    // todo: use a template\n    var str = \"\\n\"\n    if (!this._nocolors) {\n      str += chalk.bold(\"Usage:\");\n    }\n    else {\n      str += \"Usage:\";\n    }\n    str += \" \" + this._script;\n\n    var positionals = _(this.specs).select(function(opt) {\n      return opt.position != undefined;\n    })\n    positionals = _(positionals).sortBy(function(opt) {\n      return opt.position;\n    });\n    var options = _(this.specs).select(function(opt) {\n      return opt.position === undefined;\n    });\n\n    // assume there are no gaps in the specified pos. args\n    positionals.forEach(function(pos) {\n      str += \" \";\n      var posStr = pos.string;\n      if (!posStr) {\n        posStr = pos.name || \"arg\" + pos.position;\n        if (pos.required) {\n            posStr = \"<\" + posStr + \">\";\n        } else {\n            posStr = \"[\" + posStr + \"]\";\n        }\n        if (pos.list) {\n          posStr += \"...\";\n        }\n      }\n      str += posStr;\n    });\n\n    if (options.length) {\n      if (!this._nocolors) {\n        // must be a better way to do this\n        str += chalk.blue(\" [options]\");\n      }\n      else {\n        str += \" [options]\";\n      }\n    }\n\n    if (options.length || positionals.length) {\n      str += \"\\n\\n\";\n    }\n\n    function spaces(length) {\n      var spaces = \"\";\n      for (var i = 0; i < length; i++) {\n        spaces += \" \";\n      }\n      return spaces;\n    }\n    var longest = positionals.reduce(function(max, pos) {\n      return pos.name.length > max ? pos.name.length : max;\n    }, 0);\n\n    positionals.forEach(function(pos) {\n      var posStr = pos.string || pos.name;\n      str += posStr + spaces(longest - posStr.length) + \"     \";\n      if (!this._nocolors) {\n        str += chalk.grey(pos.help || \"\")\n      }\n      else {\n        str += (pos.help || \"\")\n      }\n      str += \"\\n\";\n    }, this);\n    if (positionals.length && options.length) {\n      str += \"\\n\";\n    }\n\n    if (options.length) {\n      if (!this._nocolors) {\n        str += chalk.blue(\"Options:\");\n      }\n      else {\n        str += \"Options:\";\n      }\n      str += \"\\n\"\n\n      var longest = options.reduce(function(max, opt) {\n        return opt.string.length > max && !opt.hidden ? opt.string.length : max;\n      }, 0);\n\n      options.forEach(function(opt) {\n        if (!opt.hidden) {\n          str += \"   \" + opt.string + spaces(longest - opt.string.length) + \"   \";\n\n          var defaults = (opt.default != null ? \"  [\" + opt.default + \"]\" : \"\");\n          var help = opt.help ? opt.help + defaults : \"\";\n          str += this._nocolors ? help: chalk.grey(help);\n\n          str += \"\\n\";\n        }\n      }, this);\n    }\n\n    if (this._help) {\n      str += \"\\n\" + this._help;\n    }\n    return str;\n  }\n};\n\nArgParser.prototype.opt = function(arg) {\n  // get the specified opt for this parsed arg\n  var match = Opt({});\n  this.specs.forEach(function(opt) {\n    if (opt.matches(arg)) {\n       match = opt;\n    }\n  });\n  return match;\n};\n\nArgParser.prototype.setOption = function(options, arg, value) {\n  var option = this.opt(arg);\n  if (option.callback) {\n    var message = option.callback(value);\n\n    if (typeof message == \"string\") {\n      this.print(message, 1);\n    }\n  }\n\n  if (option.type != \"string\") {\n     try {\n       // infer type by JSON parsing the string\n       value = JSON.parse(value)\n     }\n     catch(e) {}\n  }\n\n  if (option.transform) {\n     value = option.transform(value);\n  }\n\n  var name = option.name || arg;\n  if (option.choices && option.choices.indexOf(value) == -1) {\n     this.print(name + \" must be one of: \" + option.choices.join(\", \"), 1);\n  }\n\n  if (option.list) {\n    if (!options[name]) {\n      options[name] = [value];\n    }\n    else {\n      options[name].push(value);\n    }\n  }\n  else {\n    options[name] = value;\n  }\n};\n\n\n/* an arg is an item that's actually parsed from the command line\n   e.g. \"-l\", \"log.txt\", or \"--logfile=log.txt\" */\nvar Arg = function(str) {\n  var abbrRegex = /^\\-(\\w+?)$/,\n      fullRegex = /^\\-\\-(no\\-)?(.+?)(?:=(.+))?$/,\n      valRegex = /^[^\\-].*/;\n\n  var charMatch = abbrRegex.exec(str),\n      chars = charMatch && charMatch[1].split(\"\");\n\n  var fullMatch = fullRegex.exec(str),\n      full = fullMatch && fullMatch[2];\n\n  var isValue = str !== undefined && (str === \"\" || valRegex.test(str));\n  var value;\n  if (isValue) {\n    value = str;\n  }\n  else if (full) {\n    value = fullMatch[1] ? false : fullMatch[3];\n  }\n\n  return {\n    str: str,\n    chars: chars,\n    full: full,\n    value: value,\n    isValue: isValue\n  }\n}\n\n\n/* an opt is what's specified by the user in opts hash */\nvar Opt = function(opt) {\n  var strings = (opt.string || \"\").split(\",\"),\n      abbr, full, metavar;\n  for (var i = 0; i < strings.length; i++) {\n    var string = strings[i].trim(),\n        matches;\n    if (matches = string.match(/^\\-([^-])(?:\\s+(.*))?$/)) {\n      abbr = matches[1];\n      metavar = matches[2];\n    }\n    else if (matches = string.match(/^\\-\\-(.+?)(?:[=\\s]+(.+))?$/)) {\n      full = matches[1];\n      metavar = metavar || matches[2];\n    }\n  }\n\n  matches = matches || [];\n  var abbr = opt.abbr || abbr,   // e.g. v from -v\n      full = opt.full || full, // e.g. verbose from --verbose\n      metavar = opt.metavar || metavar;  // e.g. PATH from '--config=PATH'\n\n  var string;\n  if (opt.string) {\n    string = opt.string;\n  }\n  else if (opt.position === undefined) {\n    string = \"\";\n    if (abbr) {\n      string += \"-\" + abbr;\n      if (metavar)\n        string += \" \" + metavar\n      string += \", \";\n    }\n    string += \"--\" + (full || opt.name);\n    if (metavar) {\n      string += \" \" + metavar;\n    }\n  }\n\n  opt = _(opt).extend({\n    name: opt.name || full || abbr,\n    string: string,\n    abbr: abbr,\n    full: full,\n    metavar: metavar,\n    matches: function(arg) {\n      return opt.full == arg || opt.abbr == arg || opt.position == arg\n        || opt.name == arg || (opt.list && arg >= opt.position);\n    }\n  });\n  return opt;\n}\n\n\nvar createParser = function() {\n  return new ArgParser();\n}\n\nvar nomnom = createParser();\n\nfor (var i in nomnom) {\n  if (typeof nomnom[i] == \"function\") {\n     createParser[i] = _(nomnom[i]).bind(nomnom);\n  }\n}\n\nmodule.exports = createParser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nomnom/nomnom.js\n// module id = 18\n// module chunks = 0","//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/underscore/underscore.js\n// module id = 19\n// module chunks = 0","module.exports = require(\"chalk\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chalk\"\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}