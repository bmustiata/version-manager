{"version":3,"sources":["webpack:///webpack/bootstrap a2c125c3e584b2cc0620","webpack:///external \"babel-polyfill\"","webpack:///./src/main.ts","webpack:///external \"fs\"","webpack:///external \"glob\"","webpack:///external \"colors\"","webpack:///./src/SettingsReader.ts","webpack:///external \"path\"","webpack:///./src/MatcherBuilder.ts","webpack:///./src/matchers/RegExPattern.ts","webpack:///./src/matchers/StringPattern.ts","webpack:///./src/matchers/MatchCounter.ts","webpack:///./src/matchers/ArrayPattern.ts","webpack:///./src/ParseVersion.ts","webpack:///external \"child_process\""],"names":[],"mappings":"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","file":"out/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a2c125c3e584b2cc0620","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 1\n// module chunks = 0","import * as fs from \"fs\"\nimport * as glob from \"glob\"\nimport * as colors from \"colors\"\n\nimport { readSettingsFile } from './SettingsReader'\nimport { IPattern } from \"./interfaces\"\n\nconst versionsToProcess = readSettingsFile();\n\nconst filesToProcess : { [name: string] : Array<IPattern> } = {}\n\nversionsToProcess.forEach((trackedVersion) => {\n  Object.keys(trackedVersion.files).forEach((fileName) => {\n    let versionPattern = trackedVersion.files[fileName]\n    let resolvedNames = glob.sync(fileName)\n\n    if (!resolvedNames || !resolvedNames.length) {\n      console.error(colors.red(`Unable to find any files for glob ${fileName}.`))\n      process.exit(2)\n    }\n\n    // first we collect all the files that we need to process\n    // into one nice map, with all the patterns that are going\n    // to run over those files.\n    resolvedNames.forEach((resolvedName) => {\n      let filePatterns = filesToProcess[resolvedName] || []\n      filePatterns.push(versionPattern)\n      filesToProcess[resolvedName] = filePatterns\n    })\n  })\n})\n\nObject.keys(filesToProcess).forEach((resolvedName) => {\n  let content = fs.readFileSync(resolvedName, \"utf-8\")\n  let newContent = content\n    \n  console.log(`Patching ${colors.cyan(resolvedName)}:`)\n\n  filesToProcess[resolvedName].forEach((versionPattern) => {\n    let trackedVersion = versionPattern.trackedVersion\n    console.log(` * ${colors.green(trackedVersion.name + '@' + trackedVersion.version)}`)\n\n    newContent = versionPattern.applyPattern(newContent)\n\n    if (versionPattern.getMatchCount() != versionPattern.getExpectedCount()) {\n      console.error(\n        colors.red(\n          `Got ${versionPattern.getMatchCount()} matches ` +\n          `instead of ${versionPattern.getExpectedCount()}.`))\n      process.exit(3)\n    }\n  })\n\n  if (content == newContent) {\n    console.log(colors.cyan(`Content for ${resolvedName} is not changed. Won't patch it.`))\n    return;\n  }\n\n  fs.writeFileSync(resolvedName, newContent, \"utf-8\")\n  console.log(colors.yellow(`Updated ${resolvedName}`))\n})\n\nprocess.exit(0);\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"glob\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"glob\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"colors\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"colors\"\n// module id = 5\n// module chunks = 0","import * as colors from \"colors\"\nimport * as path from \"path\"\nimport * as fs from \"fs\"\n\nimport { ITrackedVersionSet, ITrackedVersion } from \"./interfaces\"\nimport { matcherBuilder } from \"./MatcherBuilder\"\nimport { parseVersion } from \"./ParseVersion\"\n\nconst settingsFile = path.join(process.cwd(), \"versions.json\");\n\n\n/**\n * readSettingsFile - Read the settings file.\n * @return {Object}\n */\nexport function readSettingsFile() : ITrackedVersionSet {\n  if (!settingsFileExists()) {\n    reportMissingSettingsFile();\n    process.exit(1);\n  }\n\n  const settings = JSON.parse(fs.readFileSync(settingsFile, \"utf-8\"));\n\n  return Object.keys(settings)\n    .map((key) => {\n      let trackedEntry = settings[key]\n\n      trackedEntry.name = key\n      trackedEntry.version = parseVersion(trackedEntry.version)\n\n      Object.keys(trackedEntry.files).forEach((file) => {\n        trackedEntry.files[file] = matcherBuilder(trackedEntry, trackedEntry.files[file])\n      })\n\n      return <ITrackedVersion> trackedEntry\n    });\n}\n\nfunction settingsFileExists() {\n  return fs.existsSync(settingsFile);\n}\n\nfunction reportMissingSettingsFile() {\n  console.log(colors.red(settingsFile + \" configuration file is missing.\"));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SettingsReader.ts","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 7\n// module chunks = 0","import { ITrackedVersion, IPattern } from \"./interfaces\"\nimport { RegExPattern } from \"./matchers/RegExPattern\"\nimport { StringPattern } from \"./matchers/StringPattern\"\nimport { MatchCounter } from \"./matchers/MatchCounter\"\nimport { ArrayPattern } from \"./matchers/ArrayPattern\"\n\nexport function matcherBuilder(trackedVersion: ITrackedVersion, fileItem: any) : IPattern {\n  if (fileItem instanceof Array) {\n    return new ArrayPattern(\n      trackedVersion, \n      fileItem.map((it) => matcherBuilder(trackedVersion, it)))\n  }\n\n  if (typeof fileItem['count'] != \"undefined\") {\n    return new MatchCounter(\n      trackedVersion,\n      matcherBuilder(\n          trackedVersion,\n          fileItem.match || fileItem.expression),\n      fileItem.count\n    );\n  }\n\n  if (fileItem.includes(\"##VERSION##\")) {\n    return new StringPattern(trackedVersion, fileItem)\n  }\n\n  return new RegExPattern(trackedVersion, fileItem)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MatcherBuilder.ts","import { ITrackedVersion, IPattern } from \"../interfaces\"\n\nexport class RegExPattern implements IPattern {\n  private RE: RegExp\n  private matchCount : number = 0\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    this.RE = new RegExp(expression, \"gm\")\n  }\n\n  applyPattern(input: string) : string {\n    let match : RegExpExecArray\n    let foundMatches: Array<RegExpExecArray> = []\n\n    while (match = this.RE.exec(input)) {\n      this.matchCount++\n      this.RE.lastIndex = match.index + match[0].length\n\n      foundMatches.push(match)\n    }\n\n    // this tracks the original input, since the matches are done\n    // aginst the unmodified string.\n    let originalIndex = 0\n    let originalInput = input\n\n    let result = \"\"\n\n    foundMatches.forEach((match) => {\n      result += originalInput.substring(originalIndex, match.index) +\n                match[1] +\n                this.trackedVersion.version +\n               (match[3] ? match[3] : \"\");\n      originalIndex = match.index + match[0].length\n    })\n\n    result += originalInput.substring(originalIndex, originalInput.length)\n\n    return result\n  }\n\n  getMatchCount() : number {\n    return this.matchCount\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/RegExPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\nimport { RegExPattern } from \"./RegExPattern\"\n\nexport class StringPattern implements IPattern {\n  private _regexPattern : RegExPattern\n\n  constructor(public trackedVersion: ITrackedVersion,\n              private expression: string) {\n    let reTokens = expression.split(\"##VERSION##\")\n\n    this._regexPattern = new RegExPattern(trackedVersion, `(${reTokens[0]})(.*?)(${reTokens[1]})`)\n  }\n  \n  applyPattern(input: string) : string {\n    return this._regexPattern.applyPattern(input)\n  }\n\n  getMatchCount() : number {\n    return this._regexPattern.getMatchCount()\n  }\n\n  getExpectedCount() : number {\n    return 1\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/StringPattern.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class MatchCounter implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePattern : IPattern,\n                private expectedCount : number) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePattern.applyPattern(input)     \n    }\n\n    getMatchCount() : number {\n        if (this.expectedCount < 0) {\n            return this.expectedCount\n        }\n\n        return this.delegatePattern.getMatchCount()\n    }\n\n    getExpectedCount() : number {\n        return this.expectedCount\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/MatchCounter.ts","import { IPattern, ITrackedVersion } from \"../interfaces\"\n\nexport class ArrayPattern implements IPattern {\n    constructor(public trackedVersion: ITrackedVersion,\n                private delegatePatterns : Array<IPattern>) {\n    }\n\n    applyPattern(input: string) : string {\n        return this.delegatePatterns\n            .reduce((input, pattern) => pattern.applyPattern(input), input)\n    }\n\n    getMatchCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getMatchCount())\n            .reduce((x, y) => x + y, 0)\n    }\n    \n    getExpectedCount() : number {\n        return this.delegatePatterns\n            .map(it => it.getExpectedCount())\n            .reduce((x, y) => x + y, 0)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/matchers/ArrayPattern.ts","import * as child_process from \"child_process\"\n\n/**\n * Parse the given version string.\n */\nexport function parseVersion(version: string) : string {\n    // if we don't need to execute anything, just go\n    // and return the current version.\n    if (! version.includes('`') && ! version.includes(\"$\")) {\n        return version\n    }\n\n    return child_process.execSync(`echo -n \"${version}\"`, {encoding: \"utf8\"})\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ParseVersion.ts","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 14\n// module chunks = 0"],"sourceRoot":""}